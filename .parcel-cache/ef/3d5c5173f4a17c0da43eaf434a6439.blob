// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

(function(modules, cache, entry, globalName) {
  /* eslint-disable no-undef */
  var globalObject =
    typeof globalThis !== 'undefined'
      ? globalThis
      : typeof self !== 'undefined'
      ? self
      : typeof window !== 'undefined'
      ? window
      : typeof global !== 'undefined'
      ? global
      : {};
  /* eslint-enable no-undef */

  // Save the require from previous bundle to this closure if any
  var previousRequire =
    typeof globalObject.parcelRequire === 'function' &&
    globalObject.parcelRequire;
  // Do not use `require` to prevent Webpack from trying to bundle this call
  var nodeRequire =
    typeof module !== 'undefined' &&
    typeof module.require === 'function' &&
    module.require.bind(module);

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire =
          typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error("Cannot find module '" + name + "'");
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = (cache[name] = new newRequire.Module(name));

      modules[name][0].call(
        module.exports,
        localRequire,
        module,
        module.exports,
        this
      );
    }

    return cache[name].exports;

    function localRequire(x) {
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x) {
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function(id, exports) {
    modules[id] = [
      function(require, module) {
        module.exports = exports;
      },
      {},
    ];
  };

  globalObject.parcelRequire = newRequire;

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === 'object' && typeof module !== 'undefined') {
      module.exports = mainExports;

      // RequireJS
    } else if (typeof define === 'function' && define.amd) {
      define(function() {
        return mainExports;
      });

      // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }
})({"ce89795720d684407d2cb270dee95d7a":[function(require,module,exports) {
"use strict";

var global = arguments[3];
var HMR_HOST = null;
var HMR_PORT = 1234;
var HMR_ENV_HASH = "d751713988987e9331980363e24189ce";
module.bundle.HMR_BUNDLE_ID = "965a882730cb32daf2ba84504e0402ee";
/* global HMR_HOST, HMR_PORT, HMR_ENV_HASH */

var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var checkedAssets, assetsToAccept, acceptedAssets; // eslint-disable-next-line no-redeclare

var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = HMR_HOST || (location.protocol.indexOf('http') === 0 ? location.hostname : 'localhost');
  var port = HMR_PORT || location.port;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + (port ? ':' + port : '') + '/');

  ws.onmessage = function (event) {
    checkedAssets = {};
    assetsToAccept = [];
    acceptedAssets = {};
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      // Remove error overlay if there is one
      removeErrorOverlay();
      let assets = data.assets.filter(asset => asset.envHash === HMR_ENV_HASH); // Handle HMR Update

      var handled = false;
      assets.forEach(asset => {
        var didAccept = asset.type === 'css' || hmrAcceptCheck(global.parcelRequire, asset.id);

        if (didAccept) {
          handled = true;
        }
      });

      if (handled) {
        console.clear();
        assets.forEach(function (asset) {
          hmrApply(global.parcelRequire, asset);
        });

        for (var i = 0; i < assetsToAccept.length; i++) {
          var id = assetsToAccept[i][1];

          if (!acceptedAssets[id]) {
            hmrAcceptRun(assetsToAccept[i][0], id);
          }
        }
      } else {
        window.location.reload();
      }
    }

    if (data.type === 'error') {
      // Log parcel errors to console
      for (let ansiDiagnostic of data.diagnostics.ansi) {
        let stack = ansiDiagnostic.codeframe ? ansiDiagnostic.codeframe : ansiDiagnostic.stack;
        console.error('ðŸš¨ [parcel]: ' + ansiDiagnostic.message + '\n' + stack + '\n\n' + ansiDiagnostic.hints.join('\n'));
      } // Render the fancy html overlay


      removeErrorOverlay();
      var overlay = createErrorOverlay(data.diagnostics.html);
      document.body.appendChild(overlay);
    }
  };

  ws.onerror = function (e) {
    console.error(e.message);
  };

  ws.onclose = function (e) {
    console.warn('[parcel] ðŸš¨ Connection to the HMR server was lost');
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
    console.log('[parcel] âœ¨ Error resolved');
  }
}

function createErrorOverlay(diagnostics) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID;
  let errorHTML = '<div style="background: black; opacity: 0.85; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; font-family: Menlo, Consolas, monospace; z-index: 9999;">';

  for (let diagnostic of diagnostics) {
    let stack = diagnostic.codeframe ? diagnostic.codeframe : diagnostic.stack;
    errorHTML += "\n      <div>\n        <div style=\"font-size: 18px; font-weight: bold; margin-top: 20px;\">\n          \uD83D\uDEA8 ".concat(diagnostic.message, "\n        </div>\n        <pre>\n          ").concat(stack, "\n        </pre>\n        <div>\n          ").concat(diagnostic.hints.map(hint => '<div>' + hint + '</div>').join(''), "\n        </div>\n      </div>\n    ");
  }

  errorHTML += '</div>';
  overlay.innerHTML = errorHTML;
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push([bundle, k]);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function updateLink(link) {
  var newLink = link.cloneNode();

  newLink.onload = function () {
    if (link.parentNode !== null) {
      link.parentNode.removeChild(link);
    }
  };

  newLink.setAttribute('href', link.getAttribute('href').split('?')[0] + '?' + Date.now());
  link.parentNode.insertBefore(newLink, link.nextSibling);
}

var cssTimeout = null;

function reloadCSS() {
  if (cssTimeout) {
    return;
  }

  cssTimeout = setTimeout(function () {
    var links = document.querySelectorAll('link[rel="stylesheet"]');

    for (var i = 0; i < links.length; i++) {
      var absolute = /^https?:\/\//i.test(links[i].getAttribute('href'));

      if (!absolute) {
        updateLink(links[i]);
      }
    }

    cssTimeout = null;
  }, 50);
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    if (asset.type === 'css') {
      reloadCSS();
    } else {
      var fn = new Function('require', 'module', 'exports', asset.output);
      modules[asset.id] = [fn, asset.depsByBundle[bundle.HMR_BUNDLE_ID]];
    }
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAcceptCheck(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAcceptCheck(bundle.parent, id);
  }

  if (checkedAssets[id]) {
    return;
  }

  checkedAssets[id] = true;
  var cached = bundle.cache[id];
  assetsToAccept.push([bundle, id]);

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    return true;
  }

  return getParents(global.parcelRequire, id).some(function (v) {
    return hmrAcceptCheck(v[0], v[1]);
  });
}

function hmrAcceptRun(bundle, id) {
  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached && cached.hot) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      var assetsToAlsoAccept = cb(function () {
        return getParents(global.parcelRequire, id);
      });

      if (assetsToAlsoAccept && assetsToAccept.length) {
        assetsToAccept.push.apply(assetsToAccept, assetsToAlsoAccept);
      }
    });
  }

  acceptedAssets[id] = true;
}
},{}],"cb7ea4a3bc30a10539152ec5958b22d4":[function(require,module,exports) {
"use strict";

require('./bundle-manifest').register(JSON.parse("{\"f2ba84504e0402ee\":\"password.965a8827.js\",\"81a5e50acc2f092e\":\"worker.js\"}"));
},{"./bundle-manifest":"ba8df6b71e73837c465d69bebde6e64d"}],"ba8df6b71e73837c465d69bebde6e64d":[function(require,module,exports) {
"use strict";

var mapping = {};

function register(pairs) {
  var keys = Object.keys(pairs);

  for (var i = 0; i < keys.length; i++) {
    mapping[keys[i]] = pairs[keys[i]];
  }
}

function resolve(id) {
  var resolved = mapping[id];

  if (resolved == null) {
    throw new Error('Could not resolve bundle with id ' + id);
  }

  return resolved;
}

module.exports.register = register;
module.exports.resolve = resolve;
},{}],"b0025b4f324d77554cb79cd8dfbefcdb":[function(require,module,exports) {
"use strict";

require("preact/debug");

var _preact = require("preact");

var _form = require("./components/form.jsx");

(0, _preact.render)((0, _preact.h)(_form.Form, null), document.getElementById('form'));

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register(require("worker.js"));
}
},{"preact/debug":"eb4970e20a2ddebf666d8f0be6df8fb5","preact":"972ceb4780c8fe42bb292a7cbd55d2e5","./components/form.jsx":"172b3b6c73c7ff9380d213ea33b522c4","worker.js":"9e8d6ed7d344d42d7638573eb6185842"}],"eb4970e20a2ddebf666d8f0be6df8fb5":[function(require,module,exports) {
var n=require("preact");require("preact/devtools");var e={};function t(e){return e.type===n.Fragment?"Fragment":"function"==typeof e.type?e.type.displayName||e.type.name:"string"==typeof e.type?e.type:"#text"}var o=[],r=[];function a(){return o.length>0?o[o.length-1]:null}var i=!1;function s(e){return"function"==typeof e.type&&e.type!=n.Fragment}function c(n){for(var e=[n],o=n;null!=o.__o;)e.push(o.__o),o=o.__o;return e.reduce(function(n,e){n+="  in "+t(e);var o=e.__source;return o?n+=" (at "+o.fileName+":"+o.lineNumber+")":i||(i=!0,console.warn("Add @babel/plugin-transform-react-jsx-source to get a more detailed component stack. Note that you should not add it to production builds of your App for bundle size reasons.")),n+"\n"},"")}var l="function"==typeof WeakMap,u=n.Component.prototype.setState;n.Component.prototype.setState=function(n,e){return null==this.__v?null==this.state&&console.warn('Calling "this.setState" inside the constructor of a component is a no-op and might be a bug in your application. Instead, set "this.state = {}" directly.\n\n'+c(a())):null==this.__P&&console.warn('Can\'t call "this.setState" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n'+c(this.__v)),u.call(this,n,e)};var p=n.Component.prototype.forceUpdate;function f(n){var e=n.props,o=t(n),r="";for(var a in e)if(e.hasOwnProperty(a)&&"children"!==a){var i=e[a];"function"==typeof i&&(i="function "+(i.displayName||i.name)+"() {}"),i=Object(i)!==i||i.toString?i+"":Object.prototype.toString.call(i),r+=" "+a+"="+JSON.stringify(i)}var s=e.children;return"<"+o+r+(s&&s.length?">..</"+o+">":" />")}n.Component.prototype.forceUpdate=function(n){return null==this.__v?console.warn('Calling "this.forceUpdate" inside the constructor of a component is a no-op and might be a bug in your application.\n\n'+c(a())):null==this.__P&&console.warn('Can\'t call "this.forceUpdate" on an unmounted component. This is a no-op, but it indicates a memory leak in your application. To fix, cancel all subscriptions and asynchronous tasks in the componentWillUnmount method.\n\n'+c(this.__v)),p.call(this,n)},function(){!function(){var e=n.options.__b,t=n.options.diffed,a=n.options.__,i=n.options.vnode,c=n.options.__r;n.options.diffed=function(n){s(n)&&r.pop(),o.pop(),t&&t(n)},n.options.__b=function(n){s(n)&&o.push(n),e&&e(n)},n.options.__=function(n,e){r=[],a&&a(n,e)},n.options.vnode=function(n){n.__o=r.length>0?r[r.length-1]:null,i&&i(n)},n.options.__r=function(n){s(n)&&r.push(n),c&&c(n)}}();var a=n.options.__b,i=n.options.diffed,u=n.options.vnode,p=n.options.__e,d=n.options.__,h=n.options.__h,y=l?{useEffect:new WeakMap,useLayoutEffect:new WeakMap,lazyPropTypes:new WeakMap}:null;n.options.__e=function(n,e,o){if(e&&e.__c&&"function"==typeof n.then){var r=n;n=new Error("Missing Suspense. The throwing component was: "+t(e));for(var a=e;a;a=a.__)if(a.__c&&a.__c.__c){n=r;break}if(n instanceof Error)throw n}p(n,e,o)},n.options.__=function(n,e){if(!e)throw new Error("Undefined parent passed to render(), this is the second argument.\nCheck if the element is available in the DOM/has the correct id.");var o;switch(e.nodeType){case 1:case 11:case 9:o=!0;break;default:o=!1}if(!o){var r=t(n);throw new Error("Expected a valid HTML node as a second argument to render.\tReceived "+e+" instead: render(<"+r+" />, "+e+");")}d&&d(n,e)},n.options.__b=function(n){var o,r,i,s=n.type,l=function n(e){return e?"function"==typeof e.type?n(e.__):e:{}}(n.__);if(void 0===s)throw new Error("Undefined component passed to createElement()\n\nYou likely forgot to export your component or might have mixed up default and named imports"+f(n)+"\n\n"+c(n));if(null!=s&&"object"==typeof s){if(void 0!==s.__k&&void 0!==s.__e)throw new Error("Invalid type passed to createElement(): "+s+"\n\nDid you accidentally pass a JSX literal as JSX twice?\n\n  let My"+t(n)+" = "+f(s)+";\n  let vnode = <My"+t(n)+" />;\n\nThis usually happens when you export a JSX literal and not the component.\n\n"+c(n));throw new Error("Invalid type passed to createElement(): "+(Array.isArray(s)?"array":s))}if("thead"!==s&&"tfoot"!==s&&"tbody"!==s||"table"===l.type?"tr"===s&&"thead"!==l.type&&"tfoot"!==l.type&&"tbody"!==l.type&&"table"!==l.type?console.error("Improper nesting of table. Your <tr> should have a <thead/tbody/tfoot/table> parent."+f(n)+"\n\n"+c(n)):"td"===s&&"tr"!==l.type?console.error("Improper nesting of table. Your <td> should have a <tr> parent."+f(n)+"\n\n"+c(n)):"th"===s&&"tr"!==l.type&&console.error("Improper nesting of table. Your <th> should have a <tr>."+f(n)+"\n\n"+c(n)):console.error("Improper nesting of table. Your <thead/tbody/tfoot> should have a <table> parent."+f(n)+"\n\n"+c(n)),void 0!==n.ref&&"function"!=typeof n.ref&&"object"!=typeof n.ref&&!("$$typeof"in n))throw new Error('Component\'s "ref" property should be a function, or an object created by createRef(), but got ['+typeof n.ref+"] instead\n"+f(n)+"\n\n"+c(n));if("string"==typeof n.type)for(var u in n.props)if("o"===u[0]&&"n"===u[1]&&"function"!=typeof n.props[u]&&null!=n.props[u])throw new Error("Component's \""+u+'" property should be a function, but got ['+typeof n.props[u]+"] instead\n"+f(n)+"\n\n"+c(n));if("function"==typeof n.type&&n.type.propTypes){if("Lazy"===n.type.displayName&&y&&!y.lazyPropTypes.has(n.type)){var p="PropTypes are not supported on lazy(). Use propTypes on the wrapped component itself. ";try{var d=n.type();y.lazyPropTypes.set(n.type,!0),console.warn(p+"Component wrapped in lazy() is "+t(d))}catch(n){console.warn(p+"We will log the wrapped component's name once it is loaded.")}}o=n.type.propTypes,r=n.props,i=t(n),Object.keys(o).forEach(function(n){var t;try{t=o[n](r,n,i,"prop",null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(n){t=n}!t||t.message in e||(e[t.message]=!0,console.error("Failed prop type: "+t.message))})}a&&a(n)},n.options.__h=function(n,e,t){if(!n)throw new Error("Hook can only be invoked from render methods.");h&&h(n,e,t)};var v=function(n,e){return{get:function(){console.warn("getting vnode."+n+" is deprecated, "+e)},set:function(){console.warn("setting vnode."+n+" is not allowed, "+e)}}},m={nodeName:v("nodeName","use vnode.type"),attributes:v("attributes","use vnode.props"),children:v("children","use vnode.props.children")},b=Object.create({},m);n.options.vnode=function(n){var e=n.props;if(null!==n.type&&null!=e&&("__source"in e||"__self"in e)){var t=n.props={};for(var o in e){var r=e[o];"__source"===o?n.__source=r:"__self"===o?n.__self=r:t[o]=r}}n.__proto__=b,u&&u(n)},n.options.diffed=function(n){n.__k&&n.__k.forEach(function(e){if(e&&void 0===e.type){delete e.__,delete e.__b;var t=Object.keys(e).join(",");throw new Error("Objects are not valid as a child. Encountered an object with the keys {"+t+"}.\n\n"+c(n))}});var e=n.__c;if(e&&e.__H){var o=e.__H;Array.isArray(o.__)&&o.__.forEach(function(e){if(e.__h&&(!e.__H||!Array.isArray(e.__H))){var o=t(n);console.warn("In "+o+" you are calling useMemo/useCallback without passing arguments.\nThis is a noop since it will not be able to memoize, it will execute it every render.\n\n"+c(n))}})}if(i&&i(n),null!=n.__k)for(var r=[],a=0;a<n.__k.length;a++){var s=n.__k[a];if(s&&null!=s.key){var l=s.key;if(-1!==r.indexOf(l)){console.error('Following component has two or more children with the same key attribute: "'+l+'". This may cause glitches and misbehavior in rendering process. Component: \n\n'+f(n)+"\n\n"+c(n));break}r.push(l)}}}}(),exports.resetPropWarnings=function(){e={}};
//# sourceMappingURL=debug.js.map

},{"preact":"972ceb4780c8fe42bb292a7cbd55d2e5","preact/devtools":"d001dd409930bf400c5c78287b2e0b49"}],"972ceb4780c8fe42bb292a7cbd55d2e5":[function(require,module,exports) {
var n,l,u,t,i,r,o,e,f={},c=[],s=/acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;function a(n,l){for(var u in l)n[u]=l[u];return n}function p(n){var l=n.parentNode;l&&l.removeChild(n)}function v(n,l,u){var t,i=arguments,r={};for(t in l)"key"!==t&&"ref"!==t&&(r[t]=l[t]);if(arguments.length>3)for(u=[u],t=3;t<arguments.length;t++)u.push(i[t]);if(null!=u&&(r.children=u),"function"==typeof n&&null!=n.defaultProps)for(t in n.defaultProps)void 0===r[t]&&(r[t]=n.defaultProps[t]);return h(n,r,l&&l.key,l&&l.ref,null)}function h(l,u,t,i,r){var o={type:l,props:u,key:t,ref:i,__k:null,__:null,__b:0,__e:null,__d:void 0,__c:null,constructor:void 0,__v:r};return null==r&&(o.__v=o),n.vnode&&n.vnode(o),o}function y(n){return n.children}function d(n,l){this.props=n,this.context=l}function x(n,l){if(null==l)return n.__?x(n.__,n.__.__k.indexOf(n)+1):null;for(var u;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e)return u.__e;return"function"==typeof n.type?x(n):null}function m(n){var l,u;if(null!=(n=n.__)&&null!=n.__c){for(n.__e=n.__c.base=null,l=0;l<n.__k.length;l++)if(null!=(u=n.__k[l])&&null!=u.__e){n.__e=n.__c.base=u.__e;break}return m(n)}}function w(l){(!l.__d&&(l.__d=!0)&&u.push(l)&&!t++||r!==n.debounceRendering)&&((r=n.debounceRendering)||i)(k)}function k(){for(var n;t=u.length;)n=u.sort(function(n,l){return n.__v.__b-l.__v.__b}),u=[],n.some(function(n){var l,u,t,i,r,o,e;n.__d&&(o=(r=(l=n).__v).__e,(e=l.__P)&&(u=[],(t=a({},r)).__v=t,i=C(e,r,t,l.__n,void 0!==e.ownerSVGElement,null,u,null==o?x(r):o),N(u,r),i!=o&&m(r)))})}function g(n,l,u,t,i,r,o,e,s,a){var v,d,m,w,k,g,_,b,A,P=t&&t.__k||c,N=P.length;for(s==f&&(s=null!=o?o[0]:N?x(t,0):null),u.__k=[],v=0;v<l.length;v++)if(null!=(w=u.__k[v]=null==(w=l[v])||"boolean"==typeof w?null:"string"==typeof w||"number"==typeof w?h(null,w,null,null,w):Array.isArray(w)?h(y,{children:w},null,null,null):null!=w.__e||null!=w.__c?h(w.type,w.props,w.key,null,w.__v):w)){if(w.__=u,w.__b=u.__b+1,null===(m=P[v])||m&&w.key==m.key&&w.type===m.type)P[v]=void 0;else for(d=0;d<N;d++){if((m=P[d])&&w.key==m.key&&w.type===m.type){P[d]=void 0;break}m=null}if(k=C(n,w,m=m||f,i,r,o,e,s,a),(d=w.ref)&&m.ref!=d&&(b||(b=[]),m.ref&&b.push(m.ref,null,w),b.push(d,w.__c||k,w)),null!=k){if(null==_&&(_=k),A=void 0,void 0!==w.__d)A=w.__d,w.__d=void 0;else if(o==m||k!=s||null==k.parentNode){n:if(null==s||s.parentNode!==n)n.appendChild(k),A=null;else{for(g=s,d=0;(g=g.nextSibling)&&d<N;d+=2)if(g==k)break n;n.insertBefore(k,s),A=s}"option"==u.type&&(n.value="")}s=void 0!==A?A:k.nextSibling,"function"==typeof u.type&&(u.__d=s)}else s&&m.__e==s&&s.parentNode!=n&&(s=x(m))}if(u.__e=_,null!=o&&"function"!=typeof u.type)for(v=o.length;v--;)null!=o[v]&&p(o[v]);for(v=N;v--;)null!=P[v]&&$(P[v],P[v]);if(b)for(v=0;v<b.length;v++)T(b[v],b[++v],b[++v])}function _(n,l,u,t,i){var r;for(r in u)"children"===r||"key"===r||r in l||A(n,r,null,u[r],t);for(r in l)i&&"function"!=typeof l[r]||"children"===r||"key"===r||"value"===r||"checked"===r||u[r]===l[r]||A(n,r,l[r],u[r],t)}function b(n,l,u){"-"===l[0]?n.setProperty(l,u):n[l]="number"==typeof u&&!1===s.test(l)?u+"px":null==u?"":u}function A(n,l,u,t,i){var r,o,e,f,c;if(i?"className"===l&&(l="class"):"class"===l&&(l="className"),"style"===l)if(r=n.style,"string"==typeof u)r.cssText=u;else{if("string"==typeof t&&(r.cssText="",t=null),t)for(f in t)u&&f in u||b(r,f,"");if(u)for(c in u)t&&u[c]===t[c]||b(r,c,u[c])}else"o"===l[0]&&"n"===l[1]?(o=l!==(l=l.replace(/Capture$/,"")),e=l.toLowerCase(),l=(e in n?e:l).slice(2),u?(t||n.addEventListener(l,P,o),(n.l||(n.l={}))[l]=u):n.removeEventListener(l,P,o)):"list"!==l&&"tagName"!==l&&"form"!==l&&"type"!==l&&"size"!==l&&!i&&l in n?n[l]=null==u?"":u:"function"!=typeof u&&"dangerouslySetInnerHTML"!==l&&(l!==(l=l.replace(/^xlink:?/,""))?null==u||!1===u?n.removeAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase()):n.setAttributeNS("http://www.w3.org/1999/xlink",l.toLowerCase(),u):null==u||!1===u&&!/^ar/.test(l)?n.removeAttribute(l):n.setAttribute(l,u))}function P(l){this.l[l.type](n.event?n.event(l):l)}function C(l,u,t,i,r,o,e,f,c){var s,p,v,h,x,m,w,k,_,b,A,P=u.type;if(void 0!==u.constructor)return null;(s=n.__b)&&s(u);try{n:if("function"==typeof P){if(k=u.props,_=(s=P.contextType)&&i[s.__c],b=s?_?_.props.value:s.__:i,t.__c?w=(p=u.__c=t.__c).__=p.__E:("prototype"in P&&P.prototype.render?u.__c=p=new P(k,b):(u.__c=p=new d(k,b),p.constructor=P,p.render=j),_&&_.sub(p),p.props=k,p.state||(p.state={}),p.context=b,p.__n=i,v=p.__d=!0,p.__h=[]),null==p.__s&&(p.__s=p.state),null!=P.getDerivedStateFromProps&&(p.__s==p.state&&(p.__s=a({},p.__s)),a(p.__s,P.getDerivedStateFromProps(k,p.__s))),h=p.props,x=p.state,v)null==P.getDerivedStateFromProps&&null!=p.componentWillMount&&p.componentWillMount(),null!=p.componentDidMount&&p.__h.push(p.componentDidMount);else{if(null==P.getDerivedStateFromProps&&k!==h&&null!=p.componentWillReceiveProps&&p.componentWillReceiveProps(k,b),!p.__e&&null!=p.shouldComponentUpdate&&!1===p.shouldComponentUpdate(k,p.__s,b)||u.__v===t.__v){for(p.props=k,p.state=p.__s,u.__v!==t.__v&&(p.__d=!1),p.__v=u,u.__e=t.__e,u.__k=t.__k,p.__h.length&&e.push(p),s=0;s<u.__k.length;s++)u.__k[s]&&(u.__k[s].__=u);break n}null!=p.componentWillUpdate&&p.componentWillUpdate(k,p.__s,b),null!=p.componentDidUpdate&&p.__h.push(function(){p.componentDidUpdate(h,x,m)})}p.context=b,p.props=k,p.state=p.__s,(s=n.__r)&&s(u),p.__d=!1,p.__v=u,p.__P=l,s=p.render(p.props,p.state,p.context),null!=p.getChildContext&&(i=a(a({},i),p.getChildContext())),v||null==p.getSnapshotBeforeUpdate||(m=p.getSnapshotBeforeUpdate(h,x)),A=null!=s&&s.type==y&&null==s.key?s.props.children:s,g(l,Array.isArray(A)?A:[A],u,t,i,r,o,e,f,c),p.base=u.__e,p.__h.length&&e.push(p),w&&(p.__E=p.__=null),p.__e=!1}else null==o&&u.__v===t.__v?(u.__k=t.__k,u.__e=t.__e):u.__e=z(t.__e,u,t,i,r,o,e,c);(s=n.diffed)&&s(u)}catch(l){u.__v=null,n.__e(l,u,t)}return u.__e}function N(l,u){n.__c&&n.__c(u,l),l.some(function(u){try{l=u.__h,u.__h=[],l.some(function(n){n.call(u)})}catch(l){n.__e(l,u.__v)}})}function z(n,l,u,t,i,r,o,e){var s,a,p,v,h,y=u.props,d=l.props;if(i="svg"===l.type||i,null!=r)for(s=0;s<r.length;s++)if(null!=(a=r[s])&&((null===l.type?3===a.nodeType:a.localName===l.type)||n==a)){n=a,r[s]=null;break}if(null==n){if(null===l.type)return document.createTextNode(d);n=i?document.createElementNS("http://www.w3.org/2000/svg",l.type):document.createElement(l.type,d.is&&{is:d.is}),r=null,e=!1}if(null===l.type)y!==d&&n.data!=d&&(n.data=d);else{if(null!=r&&(r=c.slice.call(n.childNodes)),p=(y=u.props||f).dangerouslySetInnerHTML,v=d.dangerouslySetInnerHTML,!e){if(null!=r)for(y={},h=0;h<n.attributes.length;h++)y[n.attributes[h].name]=n.attributes[h].value;(v||p)&&(v&&p&&v.__html==p.__html||(n.innerHTML=v&&v.__html||""))}_(n,d,y,i,e),v?l.__k=[]:(s=l.props.children,g(n,Array.isArray(s)?s:[s],l,u,t,"foreignObject"!==l.type&&i,r,o,f,e)),e||("value"in d&&void 0!==(s=d.value)&&s!==n.value&&A(n,"value",s,y.value,!1),"checked"in d&&void 0!==(s=d.checked)&&s!==n.checked&&A(n,"checked",s,y.checked,!1))}return n}function T(l,u,t){try{"function"==typeof l?l(u):l.current=u}catch(l){n.__e(l,t)}}function $(l,u,t){var i,r,o;if(n.unmount&&n.unmount(l),(i=l.ref)&&(i.current&&i.current!==l.__e||T(i,null,u)),t||"function"==typeof l.type||(t=null!=(r=l.__e)),l.__e=l.__d=void 0,null!=(i=l.__c)){if(i.componentWillUnmount)try{i.componentWillUnmount()}catch(l){n.__e(l,u)}i.base=i.__P=null}if(i=l.__k)for(o=0;o<i.length;o++)i[o]&&$(i[o],u,t);null!=r&&p(r)}function j(n,l,u){return this.constructor(n,u)}function D(l,u,t){var i,r,e;n.__&&n.__(l,u),r=(i=t===o)?null:t&&t.__k||u.__k,l=v(y,null,[l]),e=[],C(u,(i?u:t||u).__k=l,r||f,f,void 0!==u.ownerSVGElement,t&&!i?[t]:r?null:u.childNodes.length?c.slice.call(u.childNodes):null,e,t||f,i),N(e,l)}n={__e:function(n,l){for(var u,t;l=l.__;)if((u=l.__c)&&!u.__)try{if(u.constructor&&null!=u.constructor.getDerivedStateFromError&&(t=!0,u.setState(u.constructor.getDerivedStateFromError(n))),null!=u.componentDidCatch&&(t=!0,u.componentDidCatch(n)),t)return w(u.__E=u)}catch(l){n=l}throw n}},l=function(n){return null!=n&&void 0===n.constructor},d.prototype.setState=function(n,l){var u;u=this.__s!==this.state?this.__s:this.__s=a({},this.state),"function"==typeof n&&(n=n(u,this.props)),n&&a(u,n),null!=n&&this.__v&&(l&&this.__h.push(l),w(this))},d.prototype.forceUpdate=function(n){this.__v&&(this.__e=!0,n&&this.__h.push(n),w(this))},d.prototype.render=y,u=[],t=0,i="function"==typeof Promise?Promise.prototype.then.bind(Promise.resolve()):setTimeout,o=f,e=0,exports.render=D,exports.hydrate=function(n,l){D(n,l,o)},exports.createElement=v,exports.h=v,exports.Fragment=y,exports.createRef=function(){return{}},exports.isValidElement=l,exports.Component=d,exports.cloneElement=function(n,l){var u,t;for(t in l=a(a({},n.props),l),arguments.length>2&&(l.children=c.slice.call(arguments,2)),u={},l)"key"!==t&&"ref"!==t&&(u[t]=l[t]);return h(n.type,u,l.key||n.key,l.ref||n.ref,null)},exports.createContext=function(n){var l={},u={__c:"__cC"+e++,__:n,Consumer:function(n,l){return n.children(l)},Provider:function(n){var t,i=this;return this.getChildContext||(t=[],this.getChildContext=function(){return l[u.__c]=i,l},this.shouldComponentUpdate=function(n){i.props.value!==n.value&&t.some(function(l){l.context=n.value,w(l)})},this.sub=function(n){t.push(n);var l=n.componentWillUnmount;n.componentWillUnmount=function(){t.splice(t.indexOf(n),1),l&&l.call(n)}}),n.children}};return u.Consumer.contextType=u,u.Provider.__=u,u},exports.toChildArray=function n(l){return null==l||"boolean"==typeof l?[]:Array.isArray(l)?c.concat.apply([],l.map(n)):[l]},exports._e=$,exports.options=n;
//# sourceMappingURL=preact.js.map

},{}],"d001dd409930bf400c5c78287b2e0b49":[function(require,module,exports) {
var e=require("preact");"undefined"!=typeof window&&window.__PREACT_DEVTOOLS__&&window.__PREACT_DEVTOOLS__.attachPreact("10.4.4",e.options,{Fragment:e.Fragment,Component:e.Component});
//# sourceMappingURL=devtools.js.map

},{"preact":"972ceb4780c8fe42bb292a7cbd55d2e5"}],"172b3b6c73c7ff9380d213ea33b522c4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Form = Form;

var _preact = require("preact");

var _hooks = require("preact/hooks");

var _use_thunk_reducer = require("../use_thunk_reducer");

var _reducer = require("../reducer");

var _initial_state = require("../initial_state");

var _actions = require("../actions");

var _checkbox = require("./checkbox.jsx");

var _context = require("../context");

const steps = Array(11).fill().map((v, i) => i * 2 + 4);

function Form() {
  const hashRef = (0, _hooks.useRef)();
  const [state, dispatch] = (0, _use_thunk_reducer.useThunkReducer)(_reducer.reducer, _initial_state.initialState);
  const {
    options: {
      masterKey,
      siteTag,
      hashWordSize,
      restrictSpecial,
      restrictDigits,
      requireDigit,
      requirePunctuation,
      requireMixedCase,
      bangify
    },
    hash,
    showDetails,
    savedSites
  } = state;
  (0, _hooks.useEffect)(() => {
    const timeout = setTimeout(() => {
      dispatch((0, _actions.clearKey)());
    }, 4 * 60 * 60 * 1000);
    return () => {
      clearTimeout(timeout);
    };
  });
  (0, _hooks.useEffect)(() => {
    if (hash) {
      hashRef.current.focus();
      const selection = window.getSelection();
      const range = document.createRange();
      range.selectNode(hashRef.current);
      selection.removeAllRanges();
      selection.addRange(range);
    }
  }, [hash]);
  const changeOption = (0, _hooks.useCallback)((name, prop = 'value') => ({
    target: {
      [prop]: value
    }
  }) => dispatch((0, _actions.setOption)({
    [name]: value
  })), []);
  const copyToClipboard = (0, _hooks.useCallback)(() => {
    navigator.clipboard.writeText(hash);
  }, [hash]);
  return (0, _preact.h)(_context.Context.Provider, {
    value: state
  }, (0, _preact.h)("form", {
    onSubmit: e => dispatch((0, _actions.generateHash)(e))
  }, (0, _preact.h)("label", {
    className: "row",
    htmlFor: "master-key"
  }, "Master key", (0, _preact.h)("input", {
    id: "master-key",
    type: "password",
    autoFocus: true,
    autcomplete: "off",
    required: true,
    onInput: changeOption('masterKey'),
    onChange: () => dispatch((0, _actions.storeKey)()),
    onFocus: () => dispatch((0, _actions.clearKey)()),
    value: masterKey
  })), (0, _preact.h)("label", {
    className: "row",
    htmlFor: "site-tag"
  }, "Site tag", (0, _preact.h)("input", {
    type: "text",
    id: "site-tag",
    list: "saved-sites",
    required: true,
    autoComplete: "off",
    autoCapitalize: "none",
    autoCorrect: "off",
    onInput: changeOption('siteTag'),
    onChange: ({
      target: {
        value
      }
    }) => dispatch((0, _actions.loadSite)(value)),
    value: siteTag
  }), (0, _preact.h)("datalist", {
    "aria-label": "Saved sites",
    id: "saved-sites"
  }, savedSites.map(({
    siteTag
  }) => (0, _preact.h)("option", {
    value: siteTag,
    key: siteTag
  })))), (0, _preact.h)("button", {
    type: "submit"
  }, "Generate"), (0, _preact.h)("label", {
    className: "row",
    htmlFor: "hash"
  }, "Hash", (0, _preact.h)("output", {
    class: "hash",
    id: "hash",
    htmlFor: "site-tag",
    ref: hashRef,
    tabIndex: 0
  }, hash), (0, _preact.h)("button", {
    type: "button",
    onClick: copyToClipboard,
    hidden: !hash,
    "aria-label": "Copy to clipboard",
    title: "Copy to clipboard"
  }, "Copy")), (0, _preact.h)("details", {
    open: showDetails,
    onToggle: ({
      target: {
        open
      }
    }) => dispatch((0, _actions.setShowDetails)(open))
  }, (0, _preact.h)("summary", null, "More options"), (0, _preact.h)("button", {
    type: "button",
    onClick: () => dispatch((0, _actions.resetOptions)())
  }, "Reset"), (0, _preact.h)("button", {
    type: "button",
    onClick: () => dispatch((0, _actions.deleteSite)(siteTag)),
    hidden: !savedSites.find(({
      siteTag: t
    }) => t === siteTag)
  }, "Delete saved"), (0, _preact.h)("div", {
    class: "buttons"
  }, (0, _preact.h)("fieldset", null, (0, _preact.h)("legend", null, "Requirements"), (0, _preact.h)(_checkbox.Checkbox, {
    label: "Digits",
    onChange: changeOption('requireDigit', 'checked'),
    disabled: restrictDigits,
    checked: requireDigit
  }), (0, _preact.h)(_checkbox.Checkbox, {
    label: "Punctuation",
    onChange: changeOption('requirePunctuation', 'checked'),
    disabled: restrictDigits || restrictSpecial,
    checked: requirePunctuation
  }), (0, _preact.h)(_checkbox.Checkbox, {
    label: "Mixed case",
    onChange: changeOption('requireMixedCase', 'checked'),
    disabled: restrictDigits,
    checked: requireMixedCase
  }), (0, _preact.h)(_checkbox.Checkbox, {
    label: "Bangify",
    onChange: changeOption('bangify', 'checked'),
    checked: bangify
  })), (0, _preact.h)("fieldset", null, (0, _preact.h)("legend", null, "Restrictions"), (0, _preact.h)(_checkbox.Checkbox, {
    label: "No special",
    onChange: changeOption('restrictSpecial', 'checked'),
    disabled: restrictDigits,
    checked: restrictSpecial
  }), (0, _preact.h)(_checkbox.Checkbox, {
    label: "Digits only",
    onChange: changeOption('restrictDigits', 'checked'),
    checked: restrictDigits
  }))), (0, _preact.h)("label", {
    class: "row"
  }, "Size", ' ', (0, _preact.h)("output", {
    htmlFor: "hash-word-size",
    value: hashWordSize
  }, hashWordSize), (0, _preact.h)("input", {
    type: "range",
    id: "hash-word-size",
    min: "4",
    max: "26",
    step: "2",
    list: "step-list",
    onChange: changeOption('hashWordSize', 'valueAsNumber'),
    value: hashWordSize
  }), (0, _preact.h)("div", {
    class: "range-list"
  }, (0, _preact.h)("span", {
    class: "range-list__min"
  }, "4"), (0, _preact.h)("span", {
    class: "range-list__max"
  }, "26")), (0, _preact.h)("datalist", {
    id: "step-list"
  }, steps.map(step => (0, _preact.h)("option", {
    key: step
  }, step)))))));
}
},{"preact":"972ceb4780c8fe42bb292a7cbd55d2e5","preact/hooks":"9fa17bd51cb6bac6d24ad51f7ce5db61","../use_thunk_reducer":"d82e438d84ad0cf08b933ea8b30032a4","../reducer":"b1d6bb7179a79a0ccf183f150be3b1b0","../initial_state":"89fdaf8da2c0a0cce466d2f6903f8a23","../actions":"c3a1f97f92900f1ca3e74f1d82eca65d","./checkbox.jsx":"f15a0dbe7dbbc1ce8dca32328c319540","../context":"2f062335b3a7d5c913d7566449afdd6a"}],"9fa17bd51cb6bac6d24ad51f7ce5db61":[function(require,module,exports) {
var n,t,r,u=require("preact"),o=0,i=[],c=u.options.__r,e=u.options.diffed,f=u.options.__c,a=u.options.unmount;function p(n,r){u.options.__h&&u.options.__h(t,n,o||r),o=0;var i=t.__H||(t.__H={__:[],__h:[]});return n>=i.__.length&&i.__.push({}),i.__[n]}function s(n){return o=1,v(T,n)}function v(r,u,o){var i=p(n++,2);return i.t=r,i.__c||(i.__c=t,i.__=[o?o(u):T(void 0,u),function(n){var t=i.t(i.__[0],n);i.__[0]!==t&&(i.__[0]=t,i.__c.setState({}))}]),i.__}function x(r,o){var i=p(n++,4);!u.options.__s&&h(i.__H,o)&&(i.__=r,i.__H=o,t.__h.push(i))}function l(t,r){var u=p(n++,7);return h(u.__H,r)?(u.__H=r,u.__h=t,u.__=t()):u.__}function m(){i.some(function(n){if(n.__P)try{n.__H.__h.forEach(y),n.__H.__h.forEach(d),n.__H.__h=[]}catch(t){return n.__H.__h=[],u.options.__e(t,n.__v),!0}}),i=[]}function y(n){"function"==typeof n.u&&n.u()}function d(n){n.u=n.__()}function h(n,t){return!n||t.some(function(t,r){return t!==n[r]})}function T(n,t){return"function"==typeof t?t(n):t}u.options.__r=function(r){c&&c(r),n=0;var u=(t=r.__c).__H;u&&(u.__h.forEach(y),u.__h.forEach(d),u.__h=[])},u.options.diffed=function(n){e&&e(n);var t=n.__c;t&&t.__H&&t.__H.__h.length&&(1!==i.push(t)&&r===u.options.requestAnimationFrame||((r=u.options.requestAnimationFrame)||function(n){var t,r=function(){clearTimeout(u),cancelAnimationFrame(t),setTimeout(n)},u=setTimeout(r,100);"undefined"!=typeof window&&(t=requestAnimationFrame(r))})(m))},u.options.__c=function(n,t){t.some(function(n){try{n.__h.forEach(y),n.__h=n.__h.filter(function(n){return!n.__||d(n)})}catch(r){t.some(function(n){n.__h&&(n.__h=[])}),t=[],u.options.__e(r,n.__v)}}),f&&f(n,t)},u.options.unmount=function(n){a&&a(n);var t=n.__c;if(t&&t.__H)try{t.__H.__.forEach(y)}catch(n){u.options.__e(n,t.__v)}},exports.useState=s,exports.useReducer=v,exports.useEffect=function(r,o){var i=p(n++,3);!u.options.__s&&h(i.__H,o)&&(i.__=r,i.__H=o,t.__H.__h.push(i))},exports.useLayoutEffect=x,exports.useRef=function(n){return o=5,l(function(){return{current:n}},[])},exports.useImperativeHandle=function(n,t,r){o=6,x(function(){"function"==typeof n?n(t()):n&&(n.current=t())},null==r?r:r.concat(n))},exports.useMemo=l,exports.useCallback=function(n,t){return o=8,l(function(){return n},t)},exports.useContext=function(r){var u=t.context[r.__c],o=p(n++,9);return o.__c=r,u?(null==o.__&&(o.__=!0,u.sub(t)),u.props.value):r.__},exports.useDebugValue=function(n,t){u.options.useDebugValue&&u.options.useDebugValue(t?t(n):n)},exports.useErrorBoundary=function(r){var u=p(n++,10),o=s();return u.__=r,t.componentDidCatch||(t.componentDidCatch=function(n){u.__&&u.__(n),o[1](n)}),[o[0],function(){o[1](void 0)}]};
//# sourceMappingURL=hooks.js.map

},{"preact":"972ceb4780c8fe42bb292a7cbd55d2e5"}],"d82e438d84ad0cf08b933ea8b30032a4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useThunkReducer = useThunkReducer;

var _hooks = require("preact/hooks");

function useThunkReducer(reducer, initialState) {
  const [state, dispatch] = (0, _hooks.useReducer)(reducer, initialState); // Holds the latest state

  const stateRef = (0, _hooks.useRef)(state);
  stateRef.current = state; // Special dispatch that will call a returned function with (dispatch, getState)

  const thunkDispatch = (0, _hooks.useCallback)(data => typeof data === 'function' ? data(thunkDispatch, () => stateRef.current) : dispatch(data), []);
  return [state, thunkDispatch];
}
},{"preact/hooks":"9fa17bd51cb6bac6d24ad51f7ce5db61"}],"b1d6bb7179a79a0ccf183f150be3b1b0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.reducer = reducer;

var _actions = require("./actions");

var _hasher = _interopRequireDefault(require("./hasher"));

var _default_options = require("./default_options");

var _key_store = require("./key_store");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function optionsAreDefaults(options) {
  return Object.entries(_default_options.defaultOptions).every(([key, value]) => (options === null || options === void 0 ? void 0 : options[key]) === value);
}

function reducer(state, {
  type,
  ...params
}) {
  switch (type) {
    case _actions.GENERATE_HASH:
      {
        const {
          keyRef,
          options: {
            masterKey,
            ...saveOptions
          }
        } = state;
        return reducer({ ...state,
          hash: (0, _hasher.default)({ ...saveOptions,
            masterKey: _key_store.keyStore.get(keyRef)
          })
        }, {
          type: _actions.SAVE_SITE,
          ...saveOptions
        });
      }

    case _actions.STORE_KEY:
      {
        const {
          options: {
            masterKey
          }
        } = state;
        const keyRef = {};

        _key_store.keyStore.set(keyRef, masterKey);

        return { ...state,
          keyRef,
          options: { ...state.options,
            masterKey: Array(masterKey.length).fill('*').join('')
          }
        };
      }

    case _actions.CLEAR_KEY:
      {
        return { ...state,
          keyRef: null,
          options: { ...state.options,
            masterKey: ''
          }
        };
      }

    case _actions.SET_OPTIONS:
      return { ...state,
        options: { ..._default_options.defaultOptions,
          ...state.options,
          ...params
        }
      };

    case _actions.SET_SHOW_DETAILS:
      {
        const {
          showDetails
        } = params;
        return { ...state,
          showDetails
        };
      }

    case _actions.RESET_OPTIONS:
      {
        return { ...state,
          options: { ...state.options,
            ..._default_options.defaultOptions
          }
        };
      }

    case _actions.LOAD_SITE:
      {
        const {
          siteTag
        } = params;
        const {
          options,
          sites
        } = state;
        const newOptions = sites.get(siteTag);
        return { ...state,
          options: { ...options,
            ...newOptions
          },
          showDetails: newOptions && !optionsAreDefaults(newOptions)
        };
      }

    case _actions.DELETE_SITE:
      {
        const {
          siteTag
        } = params;
        let {
          sites,
          sync
        } = state;

        if (sites.has(siteTag)) {
          sites = new Map(sites);
          sites.delete(siteTag);
        }

        sync = [...sync, {
          type: 'delete',
          key: siteTag,
          timestamp: Date.now()
        }];
        return { ...state,
          sites,
          sync
        };
      }

    case _actions.SAVE_SITES:
      {
        const {
          sites
        } = params;
        return sites.reduce((s, site) => reducer(s, {
          type: _actions.SAVE_SITE,
          ...site
        }, state));
      }

    case _actions.SAVE_SITE:
      {
        const {
          siteTag,
          ...options
        } = params;
        let {
          sites,
          sync
        } = state;
        sites = new Map(sites);
        sites.set(siteTag, options);
        sync = [...sync, {
          type: 'add',
          key: siteTag,
          value: options,
          timestamp: Date.now()
        }];
        return { ...state,
          sites,
          sync
        };
      }

    default: // ignore

  }

  return state;
}
},{"./actions":"c3a1f97f92900f1ca3e74f1d82eca65d","./hasher":"707467735fe74142e7913180420dc0c6","./default_options":"6df684e2c471ce7529f3c444709952c1","./key_store":"aad17bc44ea954589107b72b20952981"}],"c3a1f97f92900f1ca3e74f1d82eca65d":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateHash = generateHash;
exports.resetOptions = resetOptions;
exports.storeKey = storeKey;
exports.clearKey = clearKey;
exports.setOption = setOption;
exports.setShowDetails = setShowDetails;
exports.deleteSite = deleteSite;
exports.saveSite = saveSite;
exports.saveSites = saveSites;
exports.loadSite = loadSite;
exports.LOAD_SITE = exports.DELETE_SITE = exports.SAVE_SITE = exports.SAVE_SITES = exports.SET_SHOW_DETAILS = exports.SET_OPTIONS = exports.CLEAR_KEY = exports.STORE_KEY = exports.RESET_OPTIONS = exports.GENERATE_HASH = void 0;
const GENERATE_HASH = Symbol('GENERATE_HASH');
exports.GENERATE_HASH = GENERATE_HASH;
const RESET_OPTIONS = Symbol('SET_OPTIONS');
exports.RESET_OPTIONS = RESET_OPTIONS;
const STORE_KEY = Symbol('STORE_KEY');
exports.STORE_KEY = STORE_KEY;
const CLEAR_KEY = Symbol('CLEAR_KEY');
exports.CLEAR_KEY = CLEAR_KEY;
const SET_OPTIONS = Symbol('SET_OPTIONS');
exports.SET_OPTIONS = SET_OPTIONS;
const SET_SHOW_DETAILS = Symbol('SET_SHOW_DETAILS');
exports.SET_SHOW_DETAILS = SET_SHOW_DETAILS;
const SAVE_SITES = Symbol('SAVE_SITES');
exports.SAVE_SITES = SAVE_SITES;
const SAVE_SITE = Symbol('SAVE_SITE');
exports.SAVE_SITE = SAVE_SITE;
const DELETE_SITE = Symbol('DELETE_SITE');
exports.DELETE_SITE = DELETE_SITE;
const LOAD_SITE = Symbol('LOAD_SITE');
exports.LOAD_SITE = LOAD_SITE;

function generateHash(e) {
  e.preventDefault();
  return {
    type: GENERATE_HASH
  };
}

function resetOptions() {
  return {
    type: RESET_OPTIONS
  };
}

function storeKey() {
  return {
    type: STORE_KEY
  };
}

function clearKey() {
  return {
    type: CLEAR_KEY
  };
}

function setOption(options) {
  return {
    type: SET_OPTIONS,
    ...options
  };
}

function setShowDetails(showDetails) {
  return {
    type: SET_SHOW_DETAILS,
    showDetails
  };
}

function deleteSite(siteTag) {
  return {
    type: DELETE_SITE,
    siteTag
  };
}

function saveSite(options) {
  return {
    type: SAVE_SITE,
    ...options
  };
}

function saveSites(sites) {
  return {
    type: SAVE_SITES,
    sites
  };
}

function loadSite(siteTag) {
  return {
    type: LOAD_SITE,
    siteTag
  };
}
},{}],"707467735fe74142e7913180420dc0c6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _sha = require("./sha1");

/*!
 * Version: MPL 1.1/GPL 2.0/LGPL 2.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 * http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
 * for the specific language governing rights and limitations under the
 * License.
 *
 * The Original Code is Password Hasher
 *
 * The Initial Developer of the Original Code is Steve Cooper.
 * Portions created by the Initial Developer are Copyright (C) 2006
 * the Initial Developer. All Rights Reserved.
 *
 * Contributor(s): (none)
 *
 * Alternatively, the contents of this file may be used under the terms of
 * either the GNU General Public License Version 2 or later (the "GPL"), or
 * the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
 * in which case the provisions of the GPL or the LGPL are applicable instead
 * of those above. If you wish to allow use of your version of this file only
 * under the terms of either the GPL or the LGPL, and not to allow others to
 * use your version of this file under the terms of the MPL, indicate your
 * decision by deleting the provisions above and replace them with the notice
 * and other provisions required by the GPL or the LGPL. If you do not delete
 * the provisions above, a recipient may use your version of this file under
 * the terms of any one of the MPL, the GPL or the LGPL.
 */

/*
 * This is a very specialized method to inject a character chosen from a
 * range of character codes into a block at the front of a string if one of
 * those characters is not already present.
 * Parameters:
 *  sInput   = input string
 *  offset   = offset for position of injected character
 *  reserved = # of offsets reserved for special characters
 *  seed   = seed for pseudo-randomizing the position and injected character
 *  lenOut   = length of head of string that will eventually survive truncation.
 *  cStart   = character code for first valid injected character.
 *  cNum   = number of valid character codes starting from cStart.
 */
function injectSpecialCharacter(sInput, offset, reserved, seed, lenOut, cStart, cNum) {
  const pos0 = seed % lenOut;
  const pos = (pos0 + offset) % lenOut; // Check if a qualified character is already present
  // Write the loop so that the reserved block is ignored.

  for (let i = 0; i < lenOut - reserved; i += 1) {
    const i2 = (pos0 + reserved + i) % lenOut;
    const c = sInput.charCodeAt(i2);

    if (c >= cStart && c < cStart + cNum) {
      return sInput;
    } // Already present - nothing to do

  }

  const sHead = pos > 0 ? sInput.substring(0, pos) : '';
  const sInject = String.fromCharCode((seed + sInput.charCodeAt(pos)) % cNum + cStart);
  const sTail = pos + 1 < sInput.length ? sInput.substring(pos + 1, sInput.length) : '';
  return sHead + sInject + sTail;
}
/*
 * Another specialized method to replace a class of character, e.g.
 * punctuation, with plain letters and numbers.
 * Parameters:
 *  sInput = input string
 *  seed   = seed for pseudo-randomizing the position and injected character
 *  lenOut = length of head of string that will eventually survive truncation.
 */


function removeSpecialCharacters(sInput, seed, lenOut) {
  let s = '';
  let i = 0;

  while (i < lenOut) {
    const j = sInput.substring(i).search(/[^a-z0-9]/i);

    if (j < 0) {
      break;
    }

    if (j > 0) {
      s += sInput.substring(i, i + j);
    }

    s += String.fromCharCode((seed + i) % 26 + 65);
    i += j + 1;
  }

  if (i < sInput.length) {
    s += sInput.substring(i);
  }

  return s;
}
/*
 * Convert input string to digits-only.
 * Parameters:
 *  sInput = input string
 *  seed   = seed for pseudo-randomizing the position and injected character
 *  lenOut = length of head of string that will eventually survive truncation.
 */


function convertToDigits(sInput, seed, lenOut) {
  let s = '';
  let i = 0;

  while (i < lenOut) {
    const j = sInput.substring(i).search(/[^0-9]/i);

    if (j < 0) {
      break;
    }

    if (j > 0) {
      s += sInput.substring(i, i + j);
    }

    s += String.fromCharCode((seed + sInput.charCodeAt(i)) % 10 + 48);
    i += j + 1;
  }

  if (i < sInput.length) {
    s += sInput.substring(i);
  }

  return s;
}
/*
 * IMPORTANT: This function should be changed carefully.  It must be
 * completely deterministic and consistent between releases.  Otherwise
 * users would be forced to update their passwords.  In other words, the
 * algorithm must always be backward-compatible.  It's only acceptable to
 * violate backward compatibility when new options are used.
 * SECURITY: The optional adjustments are positioned and calculated based
 * on the sum of all character codes in the raw hash string.  So it becomes
 * far more difficult to guess the injected special characters without
 * knowing the master key.
 */


var _default = ({
  siteTag,
  masterKey,
  hashWordSize,
  requireDigit,
  requirePunctuation,
  requireMixedCase,
  restrictSpecial,
  restrictDigits,
  bangify
}) => {
  // Start with the SHA1-encrypted master key/site tag.
  let s = (0, _sha.b64HmacSha1)(masterKey, siteTag); // Use the checksum of all characters as a pseudo-randomizing seed to
  // avoid making the injected characters easy to guess.  Note that it
  // isn't random in the sense of not being deterministic (i.e.
  // repeatable).  Must share the same seed between all injected
  // characters so that they are guaranteed unique positions based on
  // their offsets.

  let sum = 0;

  for (let i = 0; i < s.length; i += 1) {
    sum += s.charCodeAt(i);
  } // Restrict digits just does a mod 10 of all the characters


  if (restrictDigits) {
    s = convertToDigits(s, sum, hashWordSize);
  } else {
    // Inject digit, punctuation, and mixed case as needed.
    if (requireDigit) {
      s = injectSpecialCharacter(s, 0, 4, sum, hashWordSize, 48, 10);
    }

    if (requirePunctuation && !restrictSpecial) {
      s = injectSpecialCharacter(s, 1, 4, sum, hashWordSize, 33, 15);
    }

    if (requireMixedCase) {
      s = injectSpecialCharacter(s, 2, 4, sum, hashWordSize, 65, 26);
      s = injectSpecialCharacter(s, 3, 4, sum, hashWordSize, 97, 26);
    } // Strip out special characters as needed.


    if (restrictSpecial) {
      s = removeSpecialCharacters(s, sum, hashWordSize);
    }
  } // Trim it to size


  s = s.substr(0, hashWordSize); // Add a bang at the end

  if (bangify) {
    s = s.replace(/.$/, '!');
  }

  return s;
};

exports.default = _default;
},{"./sha1":"a1c98759bef8110f1cad7a1e1884afa5"}],"a1c98759bef8110f1cad7a1e1884afa5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hexSha1 = exports.b64HmacSha1 = void 0;

/*!
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

/* eslint-disable no-bitwise,
                  no-plusplus,
                  no-mixed-operators,
                  camelcase,
                  eqeqeq,
                  max-len,
                  no-nested-ternary,
                  no-param-reassign
*/

/*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */
const hexcase = 0;
/* hex output format. 0 - lowercase; 1 - uppercase  */

const b64pad = '';
/* base-64 pad character. "=" for strict RFC compliance   */

const chrsz = 8;
/* bits per input character. 8 - ASCII; 16 - Unicode  */

/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */

function safe_add(x, y) {
  const lsw = (x & 0xFFFF) + (y & 0xFFFF);
  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 0xFFFF;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */


function rol(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
/*
 * Convert an 8-bit or 16-bit string to an array of big-endian words
 * In 8-bit function, characters >255 have their hi-byte silently ignored.
 */


function str2binb(str) {
  const bin = [];
  const mask = (1 << chrsz) - 1;
  /* SC - Get rid of warnings */

  for (let i = 0; i < str.length * chrsz; i += chrsz) {
    if (bin[i >> 5] != undefined) {
      bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << 32 - chrsz - i % 32;
    } else {
      bin[i >> 5] = (str.charCodeAt(i / chrsz) & mask) << 32 - chrsz - i % 32;
    }
  }

  return bin;
}
/*
 * Convert an array of big-endian words to a hex string.
 */


function binb2hex(binarray) {
  const hex_tab = hexcase ? '0123456789ABCDEF' : '0123456789abcdef';
  let str = '';

  for (let i = 0; i < binarray.length * 4; i++) {
    str += hex_tab.charAt(binarray[i >> 2] >> (3 - i % 4) * 8 + 4 & 0xF) + hex_tab.charAt(binarray[i >> 2] >> (3 - i % 4) * 8 & 0xF);
  }

  return str;
}
/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */


function sha1_ft(t, b, c, d) {
  if (t < 20) {
    return b & c | ~b & d;
  }

  if (t < 40) {
    return b ^ c ^ d;
  }

  if (t < 60) {
    return b & c | b & d | c & d;
  }

  return b ^ c ^ d;
}
/*
 * Determine the appropriate additive constant for the current iteration
 */


function sha1_kt(t) {
  return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
}
/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */


function core_sha1(x, len) {
  /* append padding */
  const p = len >> 5;

  if (x[p] == undefined) {
    x[p] = 0x80 << 24 - len % 32;
  } else {
    x[p] |= 0x80 << 24 - len % 32;
  }

  x[(len + 64 >> 9 << 4) + 15] = len;
  const w = Array(80);
  let a = 1732584193;
  let b = -271733879;
  let c = -1732584194;
  let d = 271733878;
  let e = -1009589776;

  for (let i = 0; i < x.length; i += 16) {
    const olda = a;
    const oldb = b;
    const oldc = c;
    const oldd = d;
    const olde = e;

    for (let j = 0; j < 80; j++) {
      if (j < 16) {
        w[j] = x[i + j];
      } else {
        w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
      }

      const t = safe_add(safe_add(rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
      e = d;
      d = c;
      c = rol(b, 30);
      b = a;
      a = t;
    }

    a = safe_add(a, olda);
    b = safe_add(b, oldb);
    c = safe_add(c, oldc);
    d = safe_add(d, oldd);
    e = safe_add(e, olde);
  }

  return [a, b, c, d, e];
}
/*
 * Calculate the HMAC-SHA1 of a key and some data
 */


function core_hmac_sha1(key, data) {
  let bkey = str2binb(key);

  if (bkey.length > 16) {
    bkey = core_sha1(bkey, key.length * chrsz);
  }

  const ipad = Array(16);
  const opad = Array(16);

  for (let i = 0; i < 16; i++) {
    const k = bkey[i] != undefined ? bkey[i] : 0;
    ipad[i] = k ^ 0x36363636;
    opad[i] = k ^ 0x5C5C5C5C;
  }

  const hash = core_sha1(ipad.concat(str2binb(data)), 512 + data.length * chrsz);
  return core_sha1(opad.concat(hash), 512 + 160);
}
/*
 * Convert an array of big-endian words to a base-64 string
 */


function binb2b64(binarray) {
  const tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
  let str = '';

  for (let i = 0; i < binarray.length * 4; i += 3) {
    const b1 = binarray[i >> 2] != undefined ? (binarray[i >> 2] >> 8 * (3 - i % 4) & 0xFF) << 16 : 0;
    const b2 = binarray[i + 1 >> 2] != undefined ? (binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4) & 0xFF) << 8 : 0;
    const b3 = binarray[i + 2 >> 2] != undefined ? binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4) & 0xFF : 0;
    const triplet = b1 | b2 | b3;

    for (let j = 0; j < 4; j++) {
      if (i * 8 + j * 6 > binarray.length * 32) {
        str += b64pad;
      } else {
        str += tab.charAt(triplet >> 6 * (3 - j) & 0x3F);
      }
    }
  }

  return str;
}

const b64HmacSha1 = (key, data) => binb2b64(core_hmac_sha1(key, data));

exports.b64HmacSha1 = b64HmacSha1;

const hexSha1 = s => binb2hex(core_sha1(str2binb(s), s.length * chrsz));

exports.hexSha1 = hexSha1;
},{}],"6df684e2c471ce7529f3c444709952c1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultOptions = void 0;
const defaultOptions = {
  requireDigit: true,
  requirePunctuation: false,
  requireMixedCase: true,
  restrictSpecial: false,
  restrictDigits: false,
  hashWordSize: 26,
  bangify: false
};
exports.defaultOptions = defaultOptions;
},{}],"aad17bc44ea954589107b72b20952981":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keyStore = void 0;
// Store the master password in a WeakMap
// This hides the value from being easily viewed in debugging tools
const keyStore = new WeakMap();
exports.keyStore = keyStore;
},{}],"89fdaf8da2c0a0cce466d2f6903f8a23":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initialState = initialState;

var _default_options = require("./default_options");

function initialState() {
  return {
    options: {
      masterKey: '',
      siteTag: '',
      ..._default_options.defaultOptions
    },
    hash: '',
    showDetails: false,
    sync: [],
    sites: new Map()
  };
}
},{"./default_options":"6df684e2c471ce7529f3c444709952c1"}],"f15a0dbe7dbbc1ce8dca32328c319540":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Checkbox = Checkbox;

var _preact = require("preact");

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function Checkbox({
  label,
  ...props
}) {
  return (0, _preact.h)("label", null, (0, _preact.h)("input", _extends({
    type: "checkbox"
  }, props)), ' ', label);
}
},{"preact":"972ceb4780c8fe42bb292a7cbd55d2e5"}],"2f062335b3a7d5c913d7566449afdd6a":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Context = void 0;

var _preact = require("preact");

const Context = (0, _preact.createContext)();
exports.Context = Context;
},{"preact":"972ceb4780c8fe42bb292a7cbd55d2e5"}],"9e8d6ed7d344d42d7638573eb6185842":[function(require,module,exports) {
"use strict";

module.exports = require('./bundle-url').getBundleURL() + require('./relative-path')("f2ba84504e0402ee", "81a5e50acc2f092e");
},{"./bundle-url":"2146da1905b95151ed14d455c784e7b7","./relative-path":"1b9943ef25c7bbdf0dd1b9fa91880a6c"}],"2146da1905b95151ed14d455c784e7b7":[function(require,module,exports) {
"use strict";

/* globals document:readonly */
var bundleURL = null;

function getBundleURLCached() {
  if (!bundleURL) {
    bundleURL = getBundleURL();
  }

  return bundleURL;
}

function getBundleURL() {
  try {
    throw new Error();
  } catch (err) {
    var matches = ('' + err.stack).match(/(https?|file|ftp):\/\/[^)\n]+/g);

    if (matches) {
      return getBaseURL(matches[0]);
    }
  }

  return '/';
}

function getBaseURL(url) {
  return ('' + url).replace(/^((?:https?|file|ftp):\/\/.+)\/[^/]+$/, '$1') + '/';
} // TODO: Replace uses with `new URL(url).origin` when ie11 is no longer supported.


function getOrigin(url) {
  let matches = ('' + url).match(/(https?|file|ftp):\/\/[^/]+/);

  if (!matches) {
    throw new Error('Origin not found');
  }

  return matches[0];
}

exports.getBundleURL = getBundleURLCached;
exports.getBaseURL = getBaseURL;
exports.getOrigin = getOrigin;
},{}],"1b9943ef25c7bbdf0dd1b9fa91880a6c":[function(require,module,exports) {
"use strict";

var resolve = require('./bundle-manifest').resolve;

module.exports = function (fromId, toId) {
  return relative(dirname(resolve(fromId)), resolve(toId));
};

function dirname(_filePath) {
  if (_filePath === '') {
    return '.';
  }

  var filePath = _filePath[_filePath.length - 1] === '/' ? _filePath.slice(0, _filePath.length - 1) : _filePath;
  var slashIndex = filePath.lastIndexOf('/');
  return slashIndex === -1 ? '.' : filePath.slice(0, slashIndex);
}

function relative(from, to) {
  if (from === to) {
    return '';
  }

  var fromParts = from.split('/');

  if (fromParts[0] === '.') {
    fromParts.shift();
  }

  var toParts = to.split('/');

  if (toParts[0] === '.') {
    toParts.shift();
  } // Find where path segments diverge.


  var i;
  var divergeIndex;

  for (i = 0; (i < toParts.length || i < fromParts.length) && divergeIndex == null; i++) {
    if (fromParts[i] !== toParts[i]) {
      divergeIndex = i;
    }
  } // If there are segments from "from" beyond the point of divergence,
  // return back up the path to that point using "..".


  var parts = [];

  for (i = 0; i < fromParts.length - divergeIndex; i++) {
    parts.push('..');
  } // If there are segments from "to" beyond the point of divergence,
  // continue using the remaining segments.


  if (toParts.length > divergeIndex) {
    parts.push.apply(parts, toParts.slice(divergeIndex));
  }

  return parts.join('/');
}

module.exports._dirname = dirname;
module.exports._relative = relative;
},{"./bundle-manifest":"ba8df6b71e73837c465d69bebde6e64d"}]},{},["ce89795720d684407d2cb270dee95d7a","cb7ea4a3bc30a10539152ec5958b22d4","b0025b4f324d77554cb79cd8dfbefcdb"], null)

//# sourceMappingURL=password.965a8827.js.map
